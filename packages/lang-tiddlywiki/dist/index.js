import { LRParser } from '@lezer/lr';
import { NodeProp } from '@lezer/common';
import { LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
  version: 14,
  states: "!dQVQPOOOOQO'#Ci'#CiOeQPO'#CiOOQO'#Ce'#CeQVQPOOOjQPO'#CdOOQO,59T,59TOOQO-E6c-E6cOOQO,59O,59OO{QPO,59OOOQO1G.j1G.j",
  stateData: "!^~O[OS~OQPORPOSPOTQO~OVTO~OQPORPOSPOTQOUWO~OQPORPOSPOTQOUYO~O",
  goto: "r^PPPPPPPP_bPPPlRUQQSOSVSXRXTXROSTX",
  nodeNames: "âš  Program Heading1 Heading2 List Blockquote ) ( Application",
  maxTerm: 13,
  nodeProps: [
    ["openedBy", 6,"("],
    ["closedBy", 7,")"]
  ],
  skippedNodes: [0],
  repeatNodeCount: 1,
  tokenData: "!r~RXXYnYZn]^npqnqr!Pst!^xy!cyz!h!`!a!m~sS[~XYnYZn]^npqn~!UPQ~qr!X~!^OR~~!cOS~~!hOV~~!mOU~~!rOT~",
  tokenizers: [0],
  topRules: {"Program":[0,1]},
  tokenPrec: 0
});

const headingProp = new NodeProp();
const tiddlywikiLanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Application: delimitedIndent({ closing: ')', align: false })
            }),
            foldNodeProp.add({
                Application: foldInside
            }),
            headingProp.add(isHeading),
            styleTags({
                List: tags.number,
                Heading1: tags.heading1,
                Heading2: tags.heading2,
                Blockquote: tags.quote,
                // BlockComment: t.blockComment,
                '( )': tags.paren
            })
        ]
    }),
    languageData: {
        commentTokens: {
            block: {
                open: '<!--',
                close: '-->'
            }
        }
    }
});
// export const tiddlywikiCompletion = tiddlywikiLanguage.data.of({
// autocomplete: completeFromList([
//   { label: 'tiddlywiki', type: 'keyword' },
//   { label: 'define', type: 'keyword' },
//   { label: 'let', type: 'keyword' }
// ])
// });
function tiddlywiki() {
    return new LanguageSupport(tiddlywikiLanguage, []);
}
function isHeading(type) {
    let match = /^(?:ATX|Setext)Heading(\d)$/.exec(type.name);
    return match ? +match[1] : undefined;
}

export { tiddlywiki, tiddlywikiLanguage };
