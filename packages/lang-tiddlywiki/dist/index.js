import { LRParser } from '@lezer/lr';
import { NodeProp } from '@lezer/common';
import { LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
  version: 14,
  states: "nQVQPOOOOQO'#Cn'#CnOOQO'#Cj'#CjQVQPOOOOQO-E6h-E6h",
  stateData: "}~OaOS~OQPORPOSPOTPOUPOVPOWPOXPOYPOZPO[PO]PO~O",
  goto: "ncPPPPPPPPPPPPPPdPPPjQRORSRTQOR",
  nodeNames: "âš  Program Identifier Heading1 Heading2 Delete Bold UnderLine Italic Link List Blockquote LineComment Definition",
  maxTerm: 18,
  skippedNodes: [0],
  repeatNodeCount: 1,
  tokenData: "0j~R_XY!QYZ!Q]^!Qpq!Qqr!cst#rwx#}!P!Q%n!]!^'_!^!_'v!`!a*`!b!c*k!}#O,[#R#S-Y#r#s.y~!VSa~XY!QYZ!Q]^!Qpq!Q~!fQpq!lqr#T~!qSR~OY!lZ;'S!l;'S;=`!}<%lO!l~#QP;=`<%l!l~#WPpq#Z~#`SS~OY#ZZ;'S#Z;'S;=`#l<%lO#Z~#oP;=`<%l#Z~#uPpq#x~#}OY~~$QPwx$T~$WUOY$TZw$Twx$jx;'S$T;'S;=`%h<%lO$T~$mUOY$TZw$Twx%Px;'S$T;'S;=`%h<%lO$T~%UUU~OY$TZw$Twx%Px;'S$T;'S;=`%h<%lO$T~%kP;=`<%l$T~%qP!P!Q%t~%wUOY%tZ!P%t!P!Q&Z!Q;'S%t;'S;=`'X<%lO%t~&^UOY%tZ!P%t!P!Q&p!Q;'S%t;'S;=`'X<%lO%t~&uUW~OY%tZ!P%t!P!Q&p!Q;'S%t;'S;=`'X<%lO%t~'[P;=`<%l%t~'dS]~OY'_Z;'S'_;'S;=`'p<%lO'_~'sP;=`<%l'_~'yPqr'|~(PP}!O(S~(VP}!O(Y~(]UOY(YZ}(Y}!O(o!O;'S(Y;'S;=`*Y<%lO(Y~(rUOY(YZ}(Y}!O)U!O;'S(Y;'S;=`*Y<%lO(Y~)XWOY(YZ}(Y}!O)U!O!`(Y!`!a)q!a;'S(Y;'S;=`*Y<%lO(Y~)vU[~OY(YZ}(Y}!O(o!O;'S(Y;'S;=`*Y<%lO(Y~*]P;=`<%l(Y~*cPpq*f~*kOZ~~*nP!b!c*q~*tUOY*qZ!b*q!b!c+W!c;'S*q;'S;=`,U<%lO*q~+ZUOY*qZ!b*q!b!c+m!c;'S*q;'S;=`,U<%lO*q~+rUQ~OY*qZ!b*q!b!c+m!c;'S*q;'S;=`,U<%lO*q~,XP;=`<%l*q~,_P!}#O,b~,eSOY,qZ;'S,q;'S;=`-S<%lO,q~,tP#P#Q,w~,zP#P#Q,}~-SOX~~-VP;=`<%l,q~-]P#R#S-`~-cUOY-`Z#R-`#R#S-u#S;'S-`;'S;=`.s<%lO-`~-xUOY-`Z#R-`#R#S.[#S;'S-`;'S;=`.s<%lO-`~.aUV~OY-`Z#R-`#R#S.[#S;'S-`;'S;=`.s<%lO-`~.vP;=`<%l-`~.|P#r#s/P~/SUOY/PZ#r/P#r#s/f#s;'S/P;'S;=`0d<%lO/P~/iUOY/PZ#r/P#r#s/{#s;'S/P;'S;=`0d<%lO/P~0QUT~OY/PZ#r/P#r#s/{#s;'S/P;'S;=`0d<%lO/P~0gP;=`<%l/P",
  tokenizers: [0],
  topRules: {"Program":[0,1]},
  tokenPrec: 0
});

const headingProp = new NodeProp();
const tiddlywikiLanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Application: delimitedIndent({ closing: ')', align: false })
            }),
            foldNodeProp.add({
                Application: foldInside
            }),
            headingProp.add(isHeading),
            styleTags({
                Heading1: tags.heading1,
                Heading2: tags.heading2,
                Delete: tags.strikethrough,
                Bold: tags.strong,
                Underline: tags.strong,
                Identifier: tags.strong,
                Italic: tags.emphasis,
                Link: tags.link,
                List: tags.number,
                Blockquote: tags.quote,
                LineComment: tags.blockComment,
                Definition: tags.strong
            })
        ]
    }),
    languageData: {
        commentTokens: {
            block: {
                open: '<!--',
                close: '-->'
            }
        }
    }
});
// export const tiddlywikiCompletion = tiddlywikiLanguage.data.of({
// autocomplete: completeFromList([
//   { label: 'tiddlywiki', type: 'keyword' },
//   { label: 'define', type: 'keyword' },
//   { label: 'let', type: 'keyword' }
// ])
// });
function tiddlywiki() {
    return new LanguageSupport(tiddlywikiLanguage, []);
}
function isHeading(type) {
    let match = /^(?:ATX|Setext)Heading(\d)$/.exec(type.name);
    return match ? +match[1] : undefined;
}

export { tiddlywiki, tiddlywikiLanguage };
