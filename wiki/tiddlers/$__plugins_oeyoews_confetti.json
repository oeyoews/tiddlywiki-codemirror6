[
    {
        "title": "$:/plugins/oeyoews/confetti",
        "type": "application/json",
        "created": "20231103050000000",
        "text": "{\"tiddlers\":{\"$:/plugins/oeyoews/confetti/readme\":{\"title\":\"$:/plugins/oeyoews/confetti/readme\",\"text\":\"<!-- plugin template readme -->\\n\\n## Motivation\\n\\n<!-- your plugin motivation, or why you write this plugin -->\\n\",\"type\":\"text/markdown\",\"description\":\"confetti\"},\"$:/plugins/oeyoews/confetti/global.js\":{\"title\":\"$:/plugins/oeyoews/confetti/global.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/oeyoews/confetti/global.js\\ntype: application/javascript\\nmodule-type: global\\n\\n\\\\*/\\n\\nclass ConfettiGlobal {\\n  //   constructor() {}\\n\\n  static initialize() {\\n    if (!window.confetti) {\\n      require('./confetti.min.js');\\n    }\\n  }\\n  static reset() {\\n    window.confetti.reset();\\n  }\\n  // 暂时不支持实例化.\\n  static display(option = {}) {\\n    ConfettiGlobal.initialize();\\n    ConfettiGlobal.reset();\\n    window.confetti(option);\\n  }\\n\\n  static fireworks() {\\n    ConfettiGlobal.initialize();\\n    ConfettiGlobal.reset();\\n    var duration = 1 * 1000;\\n    var animationEnd = Date.now() + duration;\\n    var defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 0 };\\n\\n    function randomInRange(min, max) {\\n      return Math.random() * (max - min) + min;\\n    }\\n\\n    var interval = setInterval(function () {\\n      var timeLeft = animationEnd - Date.now();\\n\\n      if (timeLeft <= 0) {\\n        return clearInterval(interval);\\n      }\\n\\n      var particleCount = 50 * (timeLeft / duration);\\n      // since particles fall down, start a bit higher than random\\n      window.confetti({\\n        ...defaults,\\n        particleCount,\\n        origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 }\\n      });\\n      window.confetti({\\n        ...defaults,\\n        particleCount,\\n        origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 }\\n      });\\n    }, 250);\\n  }\\n\\n  static pretty() {\\n    ConfettiGlobal.initialize();\\n    ConfettiGlobal.reset();\\n    // note: you CAN only use a path for confetti.shapeFrompath(), but for\\n    // performance reasons it is best to use it once in development and save\\n    // the result to avoid the performance penalty at runtime\\n\\n    // pumpkin shape from https://thenounproject.com/icon/pumpkin-5253388/\\n    var pumpkin = confetti.shapeFromPath({\\n      path: 'M449.4 142c-5 0-10 .3-15 1a183 183 0 0 0-66.9-19.1V87.5a17.5 17.5 0 1 0-35 0v36.4a183 183 0 0 0-67 19c-4.9-.6-9.9-1-14.8-1C170.3 142 105 219.6 105 315s65.3 173 145.7 173c5 0 10-.3 14.8-1a184.7 184.7 0 0 0 169 0c4.9.7 9.9 1 14.9 1 80.3 0 145.6-77.6 145.6-173s-65.3-173-145.7-173zm-220 138 27.4-40.4a11.6 11.6 0 0 1 16.4-2.7l54.7 40.3a11.3 11.3 0 0 1-7 20.3H239a11.3 11.3 0 0 1-9.6-17.5zM444 383.8l-43.7 17.5a17.7 17.7 0 0 1-13 0l-37.3-15-37.2 15a17.8 17.8 0 0 1-13 0L256 383.8a17.5 17.5 0 0 1 13-32.6l37.3 15 37.2-15c4.2-1.6 8.8-1.6 13 0l37.3 15 37.2-15a17.5 17.5 0 0 1 13 32.6zm17-86.3h-82a11.3 11.3 0 0 1-6.9-20.4l54.7-40.3a11.6 11.6 0 0 1 16.4 2.8l27.4 40.4a11.3 11.3 0 0 1-9.6 17.5z',\\n      matrix: [\\n        0.020491803278688523, 0, 0, 0.020491803278688523, -7.172131147540983,\\n        -5.9016393442622945\\n      ]\\n    });\\n    // tree shape from https://thenounproject.com/icon/pine-tree-1471679/\\n    var tree = confetti.shapeFromPath({\\n      path: 'M120 240c-41,14 -91,18 -120,1 29,-10 57,-22 81,-40 -18,2 -37,3 -55,-3 25,-14 48,-30 66,-51 -11,5 -26,8 -45,7 20,-14 40,-30 57,-49 -13,1 -26,2 -38,-1 18,-11 35,-25 51,-43 -13,3 -24,5 -35,6 21,-19 40,-41 53,-67 14,26 32,48 54,67 -11,-1 -23,-3 -35,-6 15,18 32,32 51,43 -13,3 -26,2 -38,1 17,19 36,35 56,49 -19,1 -33,-2 -45,-7 19,21 42,37 67,51 -19,6 -37,5 -56,3 25,18 53,30 82,40 -30,17 -79,13 -120,-1l0 41 -31 0 0 -41z',\\n      matrix: [\\n        0.03597122302158273, 0, 0, 0.03597122302158273, -4.856115107913669,\\n        -5.071942446043165\\n      ]\\n    });\\n    // heart shape from https://thenounproject.com/icon/heart-1545381/\\n    var heart = confetti.shapeFromPath({\\n      path: 'M167 72c19,-38 37,-56 75,-56 42,0 76,33 76,75 0,76 -76,151 -151,227 -76,-76 -151,-151 -151,-227 0,-42 33,-75 75,-75 38,0 57,18 76,56z',\\n      matrix: [\\n        0.03333333333333333, 0, 0, 0.03333333333333333, -5.566666666666666,\\n        -5.533333333333333\\n      ]\\n    });\\n\\n    var defaults = {\\n      scalar: 2,\\n      spread: 180,\\n      particleCount: 30,\\n      origin: { y: -0.1 },\\n      startVelocity: -35\\n    };\\n\\n    confetti({\\n      ...defaults,\\n      shapes: [pumpkin],\\n      colors: ['#ff9a00', '#ff7400', '#ff4d00']\\n    });\\n    confetti({\\n      ...defaults,\\n      shapes: [tree],\\n      colors: ['#8d960f', '#be0f10', '#445404']\\n    });\\n    confetti({\\n      ...defaults,\\n      shapes: [heart],\\n      colors: ['#f93963', '#a10864', '#ee0b93']\\n    });\\n  }\\n}\\n\\nexports.Confetti = ConfettiGlobal;\\n\",\"type\":\"application/javascript\",\"module-type\":\"global\"},\"$:/plugins/oeyoews/confetti/confetti.min.js\":{\"title\":\"$:/plugins/oeyoews/confetti/confetti.min.js\",\"text\":\"// canvas-confetti v1.9.2 built on 2023-11-25T06:01:06.267Z\\n!(function (window, module) {\\n// source content\\n/* globals Map */\\n\\n(function main(global, module, isWorker, workerSize) {\\n  var canUseWorker = !!(\\n    global.Worker &&\\n    global.Blob &&\\n    global.Promise &&\\n    global.OffscreenCanvas &&\\n    global.OffscreenCanvasRenderingContext2D &&\\n    global.HTMLCanvasElement &&\\n    global.HTMLCanvasElement.prototype.transferControlToOffscreen &&\\n    global.URL &&\\n    global.URL.createObjectURL);\\n\\n  var canUsePaths = typeof Path2D === 'function' && typeof DOMMatrix === 'function';\\n  var canDrawBitmap = (function () {\\n    // this mostly supports ssr\\n    if (!global.OffscreenCanvas) {\\n      return false;\\n    }\\n\\n    var canvas = new OffscreenCanvas(1, 1);\\n    var ctx = canvas.getContext('2d');\\n    ctx.fillRect(0, 0, 1, 1);\\n    var bitmap = canvas.transferToImageBitmap();\\n\\n    try {\\n      ctx.createPattern(bitmap, 'no-repeat');\\n    } catch (e) {\\n      return false;\\n    }\\n\\n    return true;\\n  })();\\n\\n  function noop() {}\\n\\n  // create a promise if it exists, otherwise, just\\n  // call the function directly\\n  function promise(func) {\\n    var ModulePromise = module.exports.Promise;\\n    var Prom = ModulePromise !== void 0 ? ModulePromise : global.Promise;\\n\\n    if (typeof Prom === 'function') {\\n      return new Prom(func);\\n    }\\n\\n    func(noop, noop);\\n\\n    return null;\\n  }\\n\\n  var bitmapMapper = (function (skipTransform, map) {\\n    // see https://github.com/catdad/canvas-confetti/issues/209\\n    // creating canvases is actually pretty expensive, so we should create a\\n    // 1:1 map for bitmap:canvas, so that we can animate the confetti in\\n    // a performant manner, but also not store them forever so that we don't\\n    // have a memory leak\\n    return {\\n      transform: function(bitmap) {\\n        if (skipTransform) {\\n          return bitmap;\\n        }\\n\\n        if (map.has(bitmap)) {\\n          return map.get(bitmap);\\n        }\\n\\n        var canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\\n        var ctx = canvas.getContext('2d');\\n        ctx.drawImage(bitmap, 0, 0);\\n\\n        map.set(bitmap, canvas);\\n\\n        return canvas;\\n      },\\n      clear: function () {\\n        map.clear();\\n      }\\n    };\\n  })(canDrawBitmap, new Map());\\n\\n  var raf = (function () {\\n    var TIME = Math.floor(1000 / 60);\\n    var frame, cancel;\\n    var frames = {};\\n    var lastFrameTime = 0;\\n\\n    if (typeof requestAnimationFrame === 'function' && typeof cancelAnimationFrame === 'function') {\\n      frame = function (cb) {\\n        var id = Math.random();\\n\\n        frames[id] = requestAnimationFrame(function onFrame(time) {\\n          if (lastFrameTime === time || lastFrameTime + TIME - 1 < time) {\\n            lastFrameTime = time;\\n            delete frames[id];\\n\\n            cb();\\n          } else {\\n            frames[id] = requestAnimationFrame(onFrame);\\n          }\\n        });\\n\\n        return id;\\n      };\\n      cancel = function (id) {\\n        if (frames[id]) {\\n          cancelAnimationFrame(frames[id]);\\n        }\\n      };\\n    } else {\\n      frame = function (cb) {\\n        return setTimeout(cb, TIME);\\n      };\\n      cancel = function (timer) {\\n        return clearTimeout(timer);\\n      };\\n    }\\n\\n    return { frame: frame, cancel: cancel };\\n  }());\\n\\n  var getWorker = (function () {\\n    var worker;\\n    var prom;\\n    var resolves = {};\\n\\n    function decorate(worker) {\\n      function execute(options, callback) {\\n        worker.postMessage({ options: options || {}, callback: callback });\\n      }\\n      worker.init = function initWorker(canvas) {\\n        var offscreen = canvas.transferControlToOffscreen();\\n        worker.postMessage({ canvas: offscreen }, [offscreen]);\\n      };\\n\\n      worker.fire = function fireWorker(options, size, done) {\\n        if (prom) {\\n          execute(options, null);\\n          return prom;\\n        }\\n\\n        var id = Math.random().toString(36).slice(2);\\n\\n        prom = promise(function (resolve) {\\n          function workerDone(msg) {\\n            if (msg.data.callback !== id) {\\n              return;\\n            }\\n\\n            delete resolves[id];\\n            worker.removeEventListener('message', workerDone);\\n\\n            prom = null;\\n\\n            bitmapMapper.clear();\\n\\n            done();\\n            resolve();\\n          }\\n\\n          worker.addEventListener('message', workerDone);\\n          execute(options, id);\\n\\n          resolves[id] = workerDone.bind(null, { data: { callback: id }});\\n        });\\n\\n        return prom;\\n      };\\n\\n      worker.reset = function resetWorker() {\\n        worker.postMessage({ reset: true });\\n\\n        for (var id in resolves) {\\n          resolves[id]();\\n          delete resolves[id];\\n        }\\n      };\\n    }\\n\\n    return function () {\\n      if (worker) {\\n        return worker;\\n      }\\n\\n      if (!isWorker && canUseWorker) {\\n        var code = [\\n          'var CONFETTI, SIZE = {}, module = {};',\\n          '(' + main.toString() + ')(this, module, true, SIZE);',\\n          'onmessage = function(msg) {',\\n          '  if (msg.data.options) {',\\n          '    CONFETTI(msg.data.options).then(function () {',\\n          '      if (msg.data.callback) {',\\n          '        postMessage({ callback: msg.data.callback });',\\n          '      }',\\n          '    });',\\n          '  } else if (msg.data.reset) {',\\n          '    CONFETTI && CONFETTI.reset();',\\n          '  } else if (msg.data.resize) {',\\n          '    SIZE.width = msg.data.resize.width;',\\n          '    SIZE.height = msg.data.resize.height;',\\n          '  } else if (msg.data.canvas) {',\\n          '    SIZE.width = msg.data.canvas.width;',\\n          '    SIZE.height = msg.data.canvas.height;',\\n          '    CONFETTI = module.exports.create(msg.data.canvas);',\\n          '  }',\\n          '}',\\n        ].join('\\\\n');\\n        try {\\n          worker = new Worker(URL.createObjectURL(new Blob([code])));\\n        } catch (e) {\\n          // eslint-disable-next-line no-console\\n          typeof console !== undefined && typeof console.warn === 'function' ? console.warn('🎊 Could not load worker', e) : null;\\n\\n          return null;\\n        }\\n\\n        decorate(worker);\\n      }\\n\\n      return worker;\\n    };\\n  })();\\n\\n  var defaults = {\\n    particleCount: 50,\\n    angle: 90,\\n    spread: 45,\\n    startVelocity: 45,\\n    decay: 0.9,\\n    gravity: 1,\\n    drift: 0,\\n    ticks: 200,\\n    x: 0.5,\\n    y: 0.5,\\n    shapes: ['square', 'circle'],\\n    zIndex: 100,\\n    colors: [\\n      '#26ccff',\\n      '#a25afd',\\n      '#ff5e7e',\\n      '#88ff5a',\\n      '#fcff42',\\n      '#ffa62d',\\n      '#ff36ff'\\n    ],\\n    // probably should be true, but back-compat\\n    disableForReducedMotion: false,\\n    scalar: 1\\n  };\\n\\n  function convert(val, transform) {\\n    return transform ? transform(val) : val;\\n  }\\n\\n  function isOk(val) {\\n    return !(val === null || val === undefined);\\n  }\\n\\n  function prop(options, name, transform) {\\n    return convert(\\n      options && isOk(options[name]) ? options[name] : defaults[name],\\n      transform\\n    );\\n  }\\n\\n  function onlyPositiveInt(number){\\n    return number < 0 ? 0 : Math.floor(number);\\n  }\\n\\n  function randomInt(min, max) {\\n    // [min, max)\\n    return Math.floor(Math.random() * (max - min)) + min;\\n  }\\n\\n  function toDecimal(str) {\\n    return parseInt(str, 16);\\n  }\\n\\n  function colorsToRgb(colors) {\\n    return colors.map(hexToRgb);\\n  }\\n\\n  function hexToRgb(str) {\\n    var val = String(str).replace(/[^0-9a-f]/gi, '');\\n\\n    if (val.length < 6) {\\n        val = val[0]+val[0]+val[1]+val[1]+val[2]+val[2];\\n    }\\n\\n    return {\\n      r: toDecimal(val.substring(0,2)),\\n      g: toDecimal(val.substring(2,4)),\\n      b: toDecimal(val.substring(4,6))\\n    };\\n  }\\n\\n  function getOrigin(options) {\\n    var origin = prop(options, 'origin', Object);\\n    origin.x = prop(origin, 'x', Number);\\n    origin.y = prop(origin, 'y', Number);\\n\\n    return origin;\\n  }\\n\\n  function setCanvasWindowSize(canvas) {\\n    canvas.width = document.documentElement.clientWidth;\\n    canvas.height = document.documentElement.clientHeight;\\n  }\\n\\n  function setCanvasRectSize(canvas) {\\n    var rect = canvas.getBoundingClientRect();\\n    canvas.width = rect.width;\\n    canvas.height = rect.height;\\n  }\\n\\n  function getCanvas(zIndex) {\\n    var canvas = document.createElement('canvas');\\n\\n    canvas.style.position = 'fixed';\\n    canvas.style.top = '0px';\\n    canvas.style.left = '0px';\\n    canvas.style.pointerEvents = 'none';\\n    canvas.style.zIndex = zIndex;\\n\\n    return canvas;\\n  }\\n\\n  function ellipse(context, x, y, radiusX, radiusY, rotation, startAngle, endAngle, antiClockwise) {\\n    context.save();\\n    context.translate(x, y);\\n    context.rotate(rotation);\\n    context.scale(radiusX, radiusY);\\n    context.arc(0, 0, 1, startAngle, endAngle, antiClockwise);\\n    context.restore();\\n  }\\n\\n  function randomPhysics(opts) {\\n    var radAngle = opts.angle * (Math.PI / 180);\\n    var radSpread = opts.spread * (Math.PI / 180);\\n\\n    return {\\n      x: opts.x,\\n      y: opts.y,\\n      wobble: Math.random() * 10,\\n      wobbleSpeed: Math.min(0.11, Math.random() * 0.1 + 0.05),\\n      velocity: (opts.startVelocity * 0.5) + (Math.random() * opts.startVelocity),\\n      angle2D: -radAngle + ((0.5 * radSpread) - (Math.random() * radSpread)),\\n      tiltAngle: (Math.random() * (0.75 - 0.25) + 0.25) * Math.PI,\\n      color: opts.color,\\n      shape: opts.shape,\\n      tick: 0,\\n      totalTicks: opts.ticks,\\n      decay: opts.decay,\\n      drift: opts.drift,\\n      random: Math.random() + 2,\\n      tiltSin: 0,\\n      tiltCos: 0,\\n      wobbleX: 0,\\n      wobbleY: 0,\\n      gravity: opts.gravity * 3,\\n      ovalScalar: 0.6,\\n      scalar: opts.scalar,\\n      flat: opts.flat\\n    };\\n  }\\n\\n  function updateFetti(context, fetti) {\\n    fetti.x += Math.cos(fetti.angle2D) * fetti.velocity + fetti.drift;\\n    fetti.y += Math.sin(fetti.angle2D) * fetti.velocity + fetti.gravity;\\n    fetti.velocity *= fetti.decay;\\n\\n    if (fetti.flat) {\\n      fetti.wobble = 0;\\n      fetti.wobbleX = fetti.x + (10 * fetti.scalar);\\n      fetti.wobbleY = fetti.y + (10 * fetti.scalar);\\n\\n      fetti.tiltSin = 0;\\n      fetti.tiltCos = 0;\\n      fetti.random = 1;\\n    } else {\\n      fetti.wobble += fetti.wobbleSpeed;\\n      fetti.wobbleX = fetti.x + ((10 * fetti.scalar) * Math.cos(fetti.wobble));\\n      fetti.wobbleY = fetti.y + ((10 * fetti.scalar) * Math.sin(fetti.wobble));\\n\\n      fetti.tiltAngle += 0.1;\\n      fetti.tiltSin = Math.sin(fetti.tiltAngle);\\n      fetti.tiltCos = Math.cos(fetti.tiltAngle);\\n      fetti.random = Math.random() + 2;\\n    }\\n\\n    var progress = (fetti.tick++) / fetti.totalTicks;\\n\\n    var x1 = fetti.x + (fetti.random * fetti.tiltCos);\\n    var y1 = fetti.y + (fetti.random * fetti.tiltSin);\\n    var x2 = fetti.wobbleX + (fetti.random * fetti.tiltCos);\\n    var y2 = fetti.wobbleY + (fetti.random * fetti.tiltSin);\\n\\n    context.fillStyle = 'rgba(' + fetti.color.r + ', ' + fetti.color.g + ', ' + fetti.color.b + ', ' + (1 - progress) + ')';\\n\\n    context.beginPath();\\n\\n    if (canUsePaths && fetti.shape.type === 'path' && typeof fetti.shape.path === 'string' && Array.isArray(fetti.shape.matrix)) {\\n      context.fill(transformPath2D(\\n        fetti.shape.path,\\n        fetti.shape.matrix,\\n        fetti.x,\\n        fetti.y,\\n        Math.abs(x2 - x1) * 0.1,\\n        Math.abs(y2 - y1) * 0.1,\\n        Math.PI / 10 * fetti.wobble\\n      ));\\n    } else if (fetti.shape.type === 'bitmap') {\\n      var rotation = Math.PI / 10 * fetti.wobble;\\n      var scaleX = Math.abs(x2 - x1) * 0.1;\\n      var scaleY = Math.abs(y2 - y1) * 0.1;\\n      var width = fetti.shape.bitmap.width * fetti.scalar;\\n      var height = fetti.shape.bitmap.height * fetti.scalar;\\n\\n      var matrix = new DOMMatrix([\\n        Math.cos(rotation) * scaleX,\\n        Math.sin(rotation) * scaleX,\\n        -Math.sin(rotation) * scaleY,\\n        Math.cos(rotation) * scaleY,\\n        fetti.x,\\n        fetti.y\\n      ]);\\n\\n      // apply the transform matrix from the confetti shape\\n      matrix.multiplySelf(new DOMMatrix(fetti.shape.matrix));\\n\\n      var pattern = context.createPattern(bitmapMapper.transform(fetti.shape.bitmap), 'no-repeat');\\n      pattern.setTransform(matrix);\\n\\n      context.globalAlpha = (1 - progress);\\n      context.fillStyle = pattern;\\n      context.fillRect(\\n        fetti.x - (width / 2),\\n        fetti.y - (height / 2),\\n        width,\\n        height\\n      );\\n      context.globalAlpha = 1;\\n    } else if (fetti.shape === 'circle') {\\n      context.ellipse ?\\n        context.ellipse(fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI) :\\n        ellipse(context, fetti.x, fetti.y, Math.abs(x2 - x1) * fetti.ovalScalar, Math.abs(y2 - y1) * fetti.ovalScalar, Math.PI / 10 * fetti.wobble, 0, 2 * Math.PI);\\n    } else if (fetti.shape === 'star') {\\n      var rot = Math.PI / 2 * 3;\\n      var innerRadius = 4 * fetti.scalar;\\n      var outerRadius = 8 * fetti.scalar;\\n      var x = fetti.x;\\n      var y = fetti.y;\\n      var spikes = 5;\\n      var step = Math.PI / spikes;\\n\\n      while (spikes--) {\\n        x = fetti.x + Math.cos(rot) * outerRadius;\\n        y = fetti.y + Math.sin(rot) * outerRadius;\\n        context.lineTo(x, y);\\n        rot += step;\\n\\n        x = fetti.x + Math.cos(rot) * innerRadius;\\n        y = fetti.y + Math.sin(rot) * innerRadius;\\n        context.lineTo(x, y);\\n        rot += step;\\n      }\\n    } else {\\n      context.moveTo(Math.floor(fetti.x), Math.floor(fetti.y));\\n      context.lineTo(Math.floor(fetti.wobbleX), Math.floor(y1));\\n      context.lineTo(Math.floor(x2), Math.floor(y2));\\n      context.lineTo(Math.floor(x1), Math.floor(fetti.wobbleY));\\n    }\\n\\n    context.closePath();\\n    context.fill();\\n\\n    return fetti.tick < fetti.totalTicks;\\n  }\\n\\n  function animate(canvas, fettis, resizer, size, done) {\\n    var animatingFettis = fettis.slice();\\n    var context = canvas.getContext('2d');\\n    var animationFrame;\\n    var destroy;\\n\\n    var prom = promise(function (resolve) {\\n      function onDone() {\\n        animationFrame = destroy = null;\\n\\n        context.clearRect(0, 0, size.width, size.height);\\n        bitmapMapper.clear();\\n\\n        done();\\n        resolve();\\n      }\\n\\n      function update() {\\n        if (isWorker && !(size.width === workerSize.width && size.height === workerSize.height)) {\\n          size.width = canvas.width = workerSize.width;\\n          size.height = canvas.height = workerSize.height;\\n        }\\n\\n        if (!size.width && !size.height) {\\n          resizer(canvas);\\n          size.width = canvas.width;\\n          size.height = canvas.height;\\n        }\\n\\n        context.clearRect(0, 0, size.width, size.height);\\n\\n        animatingFettis = animatingFettis.filter(function (fetti) {\\n          return updateFetti(context, fetti);\\n        });\\n\\n        if (animatingFettis.length) {\\n          animationFrame = raf.frame(update);\\n        } else {\\n          onDone();\\n        }\\n      }\\n\\n      animationFrame = raf.frame(update);\\n      destroy = onDone;\\n    });\\n\\n    return {\\n      addFettis: function (fettis) {\\n        animatingFettis = animatingFettis.concat(fettis);\\n\\n        return prom;\\n      },\\n      canvas: canvas,\\n      promise: prom,\\n      reset: function () {\\n        if (animationFrame) {\\n          raf.cancel(animationFrame);\\n        }\\n\\n        if (destroy) {\\n          destroy();\\n        }\\n      }\\n    };\\n  }\\n\\n  function confettiCannon(canvas, globalOpts) {\\n    var isLibCanvas = !canvas;\\n    var allowResize = !!prop(globalOpts || {}, 'resize');\\n    var hasResizeEventRegistered = false;\\n    var globalDisableForReducedMotion = prop(globalOpts, 'disableForReducedMotion', Boolean);\\n    var shouldUseWorker = canUseWorker && !!prop(globalOpts || {}, 'useWorker');\\n    var worker = shouldUseWorker ? getWorker() : null;\\n    var resizer = isLibCanvas ? setCanvasWindowSize : setCanvasRectSize;\\n    var initialized = (canvas && worker) ? !!canvas.__confetti_initialized : false;\\n    var preferLessMotion = typeof matchMedia === 'function' && matchMedia('(prefers-reduced-motion)').matches;\\n    var animationObj;\\n\\n    function fireLocal(options, size, done) {\\n      var particleCount = prop(options, 'particleCount', onlyPositiveInt);\\n      var angle = prop(options, 'angle', Number);\\n      var spread = prop(options, 'spread', Number);\\n      var startVelocity = prop(options, 'startVelocity', Number);\\n      var decay = prop(options, 'decay', Number);\\n      var gravity = prop(options, 'gravity', Number);\\n      var drift = prop(options, 'drift', Number);\\n      var colors = prop(options, 'colors', colorsToRgb);\\n      var ticks = prop(options, 'ticks', Number);\\n      var shapes = prop(options, 'shapes');\\n      var scalar = prop(options, 'scalar');\\n      var flat = !!prop(options, 'flat');\\n      var origin = getOrigin(options);\\n\\n      var temp = particleCount;\\n      var fettis = [];\\n\\n      var startX = canvas.width * origin.x;\\n      var startY = canvas.height * origin.y;\\n\\n      while (temp--) {\\n        fettis.push(\\n          randomPhysics({\\n            x: startX,\\n            y: startY,\\n            angle: angle,\\n            spread: spread,\\n            startVelocity: startVelocity,\\n            color: colors[temp % colors.length],\\n            shape: shapes[randomInt(0, shapes.length)],\\n            ticks: ticks,\\n            decay: decay,\\n            gravity: gravity,\\n            drift: drift,\\n            scalar: scalar,\\n            flat: flat\\n          })\\n        );\\n      }\\n\\n      // if we have a previous canvas already animating,\\n      // add to it\\n      if (animationObj) {\\n        return animationObj.addFettis(fettis);\\n      }\\n\\n      animationObj = animate(canvas, fettis, resizer, size , done);\\n\\n      return animationObj.promise;\\n    }\\n\\n    function fire(options) {\\n      var disableForReducedMotion = globalDisableForReducedMotion || prop(options, 'disableForReducedMotion', Boolean);\\n      var zIndex = prop(options, 'zIndex', Number);\\n\\n      if (disableForReducedMotion && preferLessMotion) {\\n        return promise(function (resolve) {\\n          resolve();\\n        });\\n      }\\n\\n      if (isLibCanvas && animationObj) {\\n        // use existing canvas from in-progress animation\\n        canvas = animationObj.canvas;\\n      } else if (isLibCanvas && !canvas) {\\n        // create and initialize a new canvas\\n        canvas = getCanvas(zIndex);\\n        document.body.appendChild(canvas);\\n      }\\n\\n      if (allowResize && !initialized) {\\n        // initialize the size of a user-supplied canvas\\n        resizer(canvas);\\n      }\\n\\n      var size = {\\n        width: canvas.width,\\n        height: canvas.height\\n      };\\n\\n      if (worker && !initialized) {\\n        worker.init(canvas);\\n      }\\n\\n      initialized = true;\\n\\n      if (worker) {\\n        canvas.__confetti_initialized = true;\\n      }\\n\\n      function onResize() {\\n        if (worker) {\\n          // TODO this really shouldn't be immediate, because it is expensive\\n          var obj = {\\n            getBoundingClientRect: function () {\\n              if (!isLibCanvas) {\\n                return canvas.getBoundingClientRect();\\n              }\\n            }\\n          };\\n\\n          resizer(obj);\\n\\n          worker.postMessage({\\n            resize: {\\n              width: obj.width,\\n              height: obj.height\\n            }\\n          });\\n          return;\\n        }\\n\\n        // don't actually query the size here, since this\\n        // can execute frequently and rapidly\\n        size.width = size.height = null;\\n      }\\n\\n      function done() {\\n        animationObj = null;\\n\\n        if (allowResize) {\\n          hasResizeEventRegistered = false;\\n          global.removeEventListener('resize', onResize);\\n        }\\n\\n        if (isLibCanvas && canvas) {\\n          document.body.removeChild(canvas);\\n          canvas = null;\\n          initialized = false;\\n        }\\n      }\\n\\n      if (allowResize && !hasResizeEventRegistered) {\\n        hasResizeEventRegistered = true;\\n        global.addEventListener('resize', onResize, false);\\n      }\\n\\n      if (worker) {\\n        return worker.fire(options, size, done);\\n      }\\n\\n      return fireLocal(options, size, done);\\n    }\\n\\n    fire.reset = function () {\\n      if (worker) {\\n        worker.reset();\\n      }\\n\\n      if (animationObj) {\\n        animationObj.reset();\\n      }\\n    };\\n\\n    return fire;\\n  }\\n\\n  // Make default export lazy to defer worker creation until called.\\n  var defaultFire;\\n  function getDefaultFire() {\\n    if (!defaultFire) {\\n      defaultFire = confettiCannon(null, { useWorker: true, resize: true });\\n    }\\n    return defaultFire;\\n  }\\n\\n  function transformPath2D(pathString, pathMatrix, x, y, scaleX, scaleY, rotation) {\\n    var path2d = new Path2D(pathString);\\n\\n    var t1 = new Path2D();\\n    t1.addPath(path2d, new DOMMatrix(pathMatrix));\\n\\n    var t2 = new Path2D();\\n    // see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/DOMMatrix\\n    t2.addPath(t1, new DOMMatrix([\\n      Math.cos(rotation) * scaleX,\\n      Math.sin(rotation) * scaleX,\\n      -Math.sin(rotation) * scaleY,\\n      Math.cos(rotation) * scaleY,\\n      x,\\n      y\\n    ]));\\n\\n    return t2;\\n  }\\n\\n  function shapeFromPath(pathData) {\\n    if (!canUsePaths) {\\n      throw new Error('path confetti are not supported in this browser');\\n    }\\n\\n    var path, matrix;\\n\\n    if (typeof pathData === 'string') {\\n      path = pathData;\\n    } else {\\n      path = pathData.path;\\n      matrix = pathData.matrix;\\n    }\\n\\n    var path2d = new Path2D(path);\\n    var tempCanvas = document.createElement('canvas');\\n    var tempCtx = tempCanvas.getContext('2d');\\n\\n    if (!matrix) {\\n      // attempt to figure out the width of the path, up to 1000x1000\\n      var maxSize = 1000;\\n      var minX = maxSize;\\n      var minY = maxSize;\\n      var maxX = 0;\\n      var maxY = 0;\\n      var width, height;\\n\\n      // do some line skipping... this is faster than checking\\n      // every pixel and will be mostly still correct\\n      for (var x = 0; x < maxSize; x += 2) {\\n        for (var y = 0; y < maxSize; y += 2) {\\n          if (tempCtx.isPointInPath(path2d, x, y, 'nonzero')) {\\n            minX = Math.min(minX, x);\\n            minY = Math.min(minY, y);\\n            maxX = Math.max(maxX, x);\\n            maxY = Math.max(maxY, y);\\n          }\\n        }\\n      }\\n\\n      width = maxX - minX;\\n      height = maxY - minY;\\n\\n      var maxDesiredSize = 10;\\n      var scale = Math.min(maxDesiredSize/width, maxDesiredSize/height);\\n\\n      matrix = [\\n        scale, 0, 0, scale,\\n        -Math.round((width/2) + minX) * scale,\\n        -Math.round((height/2) + minY) * scale\\n      ];\\n    }\\n\\n    return {\\n      type: 'path',\\n      path: path,\\n      matrix: matrix\\n    };\\n  }\\n\\n  function shapeFromText(textData) {\\n    var text,\\n        scalar = 1,\\n        color = '#000000',\\n        // see https://nolanlawson.com/2022/04/08/the-struggle-of-using-native-emoji-on-the-web/\\n        fontFamily = '\\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\", \\\"EmojiOne Color\\\", \\\"Android Emoji\\\", \\\"Twemoji Mozilla\\\", \\\"system emoji\\\", sans-serif';\\n\\n    if (typeof textData === 'string') {\\n      text = textData;\\n    } else {\\n      text = textData.text;\\n      scalar = 'scalar' in textData ? textData.scalar : scalar;\\n      fontFamily = 'fontFamily' in textData ? textData.fontFamily : fontFamily;\\n      color = 'color' in textData ? textData.color : color;\\n    }\\n\\n    // all other confetti are 10 pixels,\\n    // so this pixel size is the de-facto 100% scale confetti\\n    var fontSize = 10 * scalar;\\n    var font = '' + fontSize + 'px ' + fontFamily;\\n\\n    var canvas = new OffscreenCanvas(fontSize, fontSize);\\n    var ctx = canvas.getContext('2d');\\n\\n    ctx.font = font;\\n    var size = ctx.measureText(text);\\n    var width = Math.ceil(size.actualBoundingBoxRight + size.actualBoundingBoxLeft);\\n    var height = Math.ceil(size.actualBoundingBoxAscent + size.actualBoundingBoxDescent);\\n\\n    var padding = 2;\\n    var x = size.actualBoundingBoxLeft + padding;\\n    var y = size.actualBoundingBoxAscent + padding;\\n    width += padding + padding;\\n    height += padding + padding;\\n\\n    canvas = new OffscreenCanvas(width, height);\\n    ctx = canvas.getContext('2d');\\n    ctx.font = font;\\n    ctx.fillStyle = color;\\n\\n    ctx.fillText(text, x, y);\\n\\n    var scale = 1 / scalar;\\n\\n    return {\\n      type: 'bitmap',\\n      // TODO these probably need to be transfered for workers\\n      bitmap: canvas.transferToImageBitmap(),\\n      matrix: [scale, 0, 0, scale, -width * scale / 2, -height * scale / 2]\\n    };\\n  }\\n\\n  module.exports = function() {\\n    return getDefaultFire().apply(this, arguments);\\n  };\\n  module.exports.reset = function() {\\n    getDefaultFire().reset();\\n  };\\n  module.exports.create = confettiCannon;\\n  module.exports.shapeFromPath = shapeFromPath;\\n  module.exports.shapeFromText = shapeFromText;\\n}((function () {\\n  if (typeof window !== 'undefined') {\\n    return window;\\n  }\\n\\n  if (typeof self !== 'undefined') {\\n    return self;\\n  }\\n\\n  return this || {};\\n})(), module, false));\\n\\n// end source content\\n\\n  window.confetti = module.exports;\\n}(window, {}));\",\"type\":\"application/javascript\",\"module-type\":\"library\"}}}",
        "description": "confetti",
        "author": "oeyoews",
        "version": "0.0.1",
        "core-version": ">=5.3.0",
        "plugin-type": "plugin",
        "name": "confetti",
        "meat#disabled": "yes",
        "qrcode": "yes",
        "dependents": "$:/plugins/oeyoews/tiddlywiki-tailwindcss-plus",
        "list": "readme"
    }
]